(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["entireGame"],{"0056":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"entireGame"}},[null!=e.runningGame&&0==e.gameEnd?n("div",{staticStyle:{"font-size":"15px",color:"red","font-weight":"600"}},[e._v(e._s(1===e.lang?"上、左、右键移动角色，esc键暂停":"Press [left,right,up] key to move player. Press [esc]key to pause the game."))]):e._e(),null==e.runningGame?n("div",{staticClass:"startUpFace",style:e.backgroundStyle},[n("button",{style:e.startUpBtn,on:{click:function(t){return e.startGame()}}},[e._v(e._s(e.startUpBtnText))]),e._l(e.processTextComponent,function(t,a){return n("div",{key:"textItem"+a,staticClass:"textItem",style:t.style},[e._v(e._s(t.textContent))])}),e._l(e.processPictureComponent,function(e,t){return n("div",{key:"pictureItem"+t,staticClass:"imgItem",style:e.style},[n("img",{attrs:{src:e.url,width:e.width}})])})],2):e._e(),e.gameEnd?n("div",{staticClass:"endFace",style:e.endBackgroundStyle},[n("pre",{staticClass:"textFlow",style:e.textFlowRealTimeStyle},[e._v(e._s(e.endProcessTextFlow.textContent))]),e._l(e.endProcessTextComponent,function(t,a){return n("div",{key:"textItem"+a,staticClass:"textItem",style:t.style},[e._v(e._s(t.textContent))])}),e._l(e.endProcessPictureComponent,function(e,t){return n("div",{key:"pictureItem"+t,staticClass:"imgItem",style:e.style},[n("img",{attrs:{src:e.url,width:e.width}})])})],2):e._e(),n("div",{staticClass:"gameContainer"}),n("div",{staticClass:"btnGroup"},[n("button",{staticClass:"designBtn",on:{click:function(t){return e.goToPlayerFigureDesign()}}},[n("font-awesome-icon",{staticClass:"fa-lg",attrs:{icon:"male"}}),e._v(" "+e._s(1===e.lang?"角色设计":"Player")+"\n    ")],1),n("button",{staticClass:"designBtn",on:{click:function(t){return e.goToGameDesign()}}},[n("font-awesome-icon",{staticClass:"fa-lg",attrs:{icon:"gamepad"}}),e._v(" "+e._s(1===e.lang?"游戏设计":"Level")+"\n    ")],1),n("button",{staticClass:"designBtn",on:{click:function(t){return e.goToStartUpAndEndDesign()}}},[n("font-awesome-icon",{staticClass:"fa-lg",attrs:{icon:"laptop"}}),e._v(" "+e._s(1===e.lang?"界面设计":"Interface")+"\n    ")],1),n("button",{on:{click:function(t){return e.reset()}}},[e._v(e._s(e.gameEnd?1===e.lang?"重置游戏":"reset":1===e.lang?"结束游戏":"reset"))]),n("button",{on:{click:function(t){return e.save()}}},[e._v(e._s(1===e.lang?"保存":"save"))]),n("button",{on:{click:function(t){return e.restore()}}},[e._v(e._s(1===e.lang?"恢复":"restore"))]),n("button",{on:{click:function(t){return e.downloadTheGame()}}},[e._v(e._s(1===e.lang?"下载":"download"))])]),n("div",{staticClass:"downLoadConfirm"})])},s=[],r=(n("3b2b"),n("5d73")),i=n.n(r),o=(n("5df3"),n("a481"),n("795b")),l=n.n(o),c=(n("96cf"),n("3b8d")),p=(n("4917"),n("c5f6"),n("cebc")),u=n("f499"),h=n.n(u),d=(n("ac6a"),n("4948")),m=n("eb78"),f=n("2f62"),g='\n<!DOCTYPE html>\n<html>\n\n<head>\n   <meta charset="utf-8">\n   <title></title>\n\n</head>\n\n<style>\nhtml{\n   padding-top:100px\n}\n</style>\n\n<body>\n   <div id=\'game\'></div>\n</body>\n<script>\n\n\n\n   let GAME_LEVELS = gameLevelToBeReplaced\n   let gameSettings = gameSettingsToBeReplaced\n   let globalSettings = globalSettingsToBeReplaced\n\n   /* eslint-disable no-console */\n   ////放大倍数\n   var scale = 20;\n   var gameWidth = 700;\n   var gameHeight = 400;\n\n   ////每个actor的图片来源\n\n   let spritesSRC = spritesToBeReplaced\n   let playerSRC = playerToBeReplaced\n   let monsterSRC = monsterToBeReplaced\n   let drgonSRC = drgonToBeReplaced\n   let fireSRC = fileToBeReplaced\n   let dragonToFire = dragonToFireToBeReplaced\n\n   let otherSprites = srcToImage(spritesSRC)\n   let monsterSprites = srcToImage(monsterSRC)\n   let dragonSpritesSRC = srcToImage(drgonSRC);\n   let fireSpritesSRC = srcToImage(fireSRC);\n   let toFireSRC = srcToImage(dragonToFire)\n\n   function getImage(name, length) {\n      if (length == undefined) {\n         let image = new Image();\n         let src = \'../src/pic/pureGame/\' + name \n         if (src == undefined) throw new Error(\'no such image\')\n         image.src = src\n         return image\n      } else {\n         return Array.apply(null, { length: length }).map(function (_, index) {\n            let fileIndex = index + 1\n            let fileName = name.replace(/[.]/, fileIndex + ".")\n            return getImage(fileName)\n         })\n      }\n   }\n\n   function srcToImage(src){\n      if (typeof src == \'string\'){\n         let image = new Image();\n         image.src = src;\n         return image;\n      }else{\n         return Array.apply(null,{length:src.length}).map(function(_,index){\n            return srcToImage(src[index])\n         })\n      }\n   }\n\n\n\n   ////背景图片\n   //let gameBackgroundImg = document.createElement(\'img\');\n\n   //第一章：基础设置：level、state、actors。。。\n\n   var Level = class Level {\n      constructor(plan) {\n         //地图的基本信息\n         let rows = plan.trim().split("\\n").map(l => {\n            l = l.trim();\n            return [...l]\n         });\n         this.height = rows.length;\n         this.width = rows[0].length;\n         this.startActors = [];\n\n         this.rows = rows.map((row, y) => {\n            return row.map((ch, x) => {\n               let type = levelChars[ch];\n               if (typeof type == "string") return type;\n               this.startActors.push(\n                  type.create(new Vec(x, y), ch));\n               return "empty";\n            });\n         });\n      }\n      touches(pos, size, type) {\n         //某个位置（可以是任何actor的位置） 与 背景（墙、钱）的碰撞测试\n         var xStart = Math.floor(pos.x);\n         var xEnd = Math.ceil(pos.x + size.x);\n         var yStart = Math.floor(pos.y);\n         var yEnd = Math.ceil(pos.y + size.y);\n\n         for (var y = yStart; y < yEnd; y++) {\n            for (var x = xStart; x < xEnd; x++) {\n               let isOutside = x < 0 || x >= this.width ||\n                  y < 0 || y >= this.height;\n               let here = isOutside ? "wall" : this.rows[y][x];\n               if (typeof type == "string") {\n                  if (here == type) return true;\n               } else if (typeof type == \'object\') {\n                  //type必须是array，同时测试与多个type之间的碰撞\n                  if (type.some(a => here == a)) return true\n               }\n            }\n         }\n         return false;\n      }\n   }\n\n   var State = class State {\n      constructor(level, actors, status) {\n         this.level = level;\n         this.actors = actors;\n         this.status = status;\n      }\n\n      static start(level) {\n         return new State(level, level.startActors, "playing");\n      }\n\n      get player() {\n         if (this.actors.find(a => a.type == "player") == undefined) {\n            throw new Error(\'here\')\n         }\n         return this.actors.find(a => a.type == "player");\n      }\n      update(time, keys, gameClass) {\n         let actors = this.actors\n            .map(actor => actor.update(time, this, keys, gameClass));\n         let newState = new State(this.level, actors, this.status);\n         //先看this.status的状态\n         if (newState.status != "playing") return newState;\n         //再看player有没有撞lava\n         let player = newState.player;\n         if (this.level.touches(player.pos, player.size, "lava")) {\n            return new State(this.level, actors, "lost");\n         }\n         //再处理actors之间的碰撞以及增添或删除actors\n         for (let actor of actors) {\n            if (actor != player && overlap(player, actor)) {\n               newState = actor.collide(newState);\n            }\n            if (actor.type == "fire" && actor.isGone) {\n               newState = actor.gone(newState)\n            } else if (actor.type == "dragon" && actor.fire.isFire) {\n               newState = actor.firing(newState)\n            }\n         }\n         return newState;\n      }\n   }\n\n   var Vec = class Vec {\n      constructor(x, y) {\n         this.x = x; this.y = y;\n      }\n      plus(other) {\n         return new Vec(this.x + other.x, this.y + other.y);\n      }\n      times(factor) {\n         return new Vec(this.x * factor, this.y * factor);\n      }\n   }\n\n   var Player = class Player {\n      constructor(pos, speed, property) {\n         this.pos = pos;\n         this.speed = speed;\n         this.size = new Vec(0.8, 1.5).times(property==undefined?1:property.size)\n         this.playerXSpeed = property == undefined ? 7 : property.speed;\n         this.gravity = 30;\n         this.jumpSpeed = property == undefined ? 17 : property.jumpSpeed;\n      }\n      get type() {\n         return "player";\n      }\n      static create(pos) {\n         return new Player(pos.plus(new Vec(0, -2.1)), new Vec(0, 0));\n      }\n      update(time, state, keys, property) {\n         let xSpeed = 0;\n         if (keys.ArrowLeft) xSpeed -= this.playerXSpeed;\n         if (keys.ArrowRight) xSpeed += this.playerXSpeed;\n         let pos = this.pos;\n         let movedX = pos.plus(new Vec(xSpeed * time, 0));\n         if (!state.level.touches(movedX, this.size, "wall")) {\n            pos = movedX;\n         }\n         let ySpeed = this.speed.y + time * this.gravity;\n         let movedY = pos.plus(new Vec(0, ySpeed * time));\n         if (!state.level.touches(movedY, this.size, "wall")) {\n            pos = movedY;\n         } else if (keys.ArrowUp && ySpeed > 0) {\n            ySpeed = -this.jumpSpeed;\n         } else {\n            ySpeed = 0;\n         }\n         return new Player(pos, new Vec(xSpeed, ySpeed), property);\n      }\n   }\n\n   var Lava = class Lava {\n      constructor(pos, speed, reset) {\n         this.pos = pos;\n         this.speed = speed;\n         this.reset = reset;\n         this.size = new Vec(1, 1)\n      }\n\n      get type() { return "lava"; }\n\n      static create(pos, ch) {\n         if (ch == "=") {\n            return new Lava(pos, new Vec(2, 0));\n         } else if (ch == "|") {\n            return new Lava(pos, new Vec(0, 2));\n         } else if (ch == "v") {\n            return new Lava(pos, new Vec(0, 3), pos);\n         }\n      }\n      collide(state) {\n         return new State(state.level, state.actors, "lost");\n      }\n      update(time, state) {\n         let newPos = this.pos.plus(this.speed.times(time));\n         if (!state.level.touches(newPos, this.size, "wall")) {\n            return new Lava(newPos, this.speed, this.reset);\n         } else if (this.reset) {\n            return new Lava(this.reset, this.speed, this.reset);\n         } else {\n            return new Lava(this.pos, this.speed.times(-1));\n         }\n      }\n   }\n\n   var Coin = class Coin {\n      constructor(pos, basePos, wobble) {\n         this.pos = pos;\n         this.basePos = basePos;\n         this.wobble = wobble;\n         this.size = new Vec(0.6, 0.6);\n         this.wobbleSpeed = 8;\n         this.wobbleDist = 0.07;\n      }\n\n      get type() { return "coin"; }\n\n      static create(pos) {\n         let basePos = pos.plus(new Vec(0.2, 0.1));\n         return new Coin(basePos, basePos,\n            Math.random() * Math.PI * 2);\n      }\n      collide(state) {\n         let filtered = state.actors.filter(a => a != this);\n         let status = state.status;\n         if (!filtered.some(a => a.type == "coin")) status = "won";\n         return new State(state.level, filtered, status);\n      }\n      update(time) {\n         let wobble = this.wobble + time * this.wobbleSpeed;\n         let wobblePos = Math.sin(wobble) * this.wobbleDist;\n         return new Coin(this.basePos.plus(new Vec(0, wobblePos)),\n            this.basePos, wobble);\n      }\n   }\n\n   class Monster {\n      constructor(pos, speed) {\n         this.pos = pos;\n         this.speed = speed;\n         this.size = new Vec(1, 1)\n      }\n      get type() {\n         return \'monster\'\n      }\n      static create(pos) {\n         return new Monster(pos, new Vec(-2, 7))\n      }\n      collide(state) {\n         return new State(state.level, state.actors, \'lost\');\n      }\n      update(time, state) {\n         let xSpeed = this.speed.x;\n         let pos = this.pos;\n         let movedX = pos.plus(new Vec(xSpeed * time, 0))\n         if (!state.level.touches(movedX, this.size, ["wall", "lava"])) {\n            pos = movedX\n         } else {\n            xSpeed = -this.speed.x;\n         }\n         let ySpeed = this.speed.y;\n         let movedY = pos.plus(new Vec(0, ySpeed * time));\n         if (!state.level.touches(movedY, this.size, ["wall", "lava"])) {\n            pos = movedY\n         }\n         return new Monster(pos, new Vec(xSpeed, ySpeed))\n      }\n   }\n\n   class Dragon {\n      constructor(pos, speed, fire = { isFire: false, lastShot: 0 }) {\n         this.pos = pos;\n         this.speed = speed;\n         this.size = new Vec(1.5, 1.5)\n         this.fire = fire;\n      }\n      get type() {\n         return \'dragon\'\n      }\n      static create(pos) {\n         return new Dragon(pos, new Vec(0, 0))\n      }\n      collide(state) {\n         return new State(state.level, state.actors, \'lost\')\n      }\n      firing(state) {\n         let xSpeed = this.speed.x > 0 ? 5 : -5\n         let fire = new Fire(this.pos, new Vec(xSpeed, 0))\n         let actors = state.actors;\n         actors.push(fire)\n         return new State(state.level, actors, state.status)\n      }\n      update(time, state) {\n         let player = state.player\n         //会跟踪player，一定距离之内会喷火\n\n         let xDistance = player.pos.x - this.pos.x;\n         let xSpeed = xDistance > 0 ? 2 : -2\n         if (Math.abs(xDistance) < 0.1) {\n            xSpeed = 0;\n         }\n         let pos = this.pos;\n         let movedX = pos.plus(new Vec(xSpeed * time, 0))\n         if (!state.level.touches(movedX, this.size, ["wall", "lava"])) {\n            pos = movedX\n         }\n\n         let yDistance = player.pos.y - this.pos.y;\n         let ySpeed = yDistance > 0 ? 2.5 : -1.5\n         if (Math.abs(yDistance) < 0.1) ySpeed = 0;\n         let movedY = pos.plus(new Vec(0, ySpeed * time));\n         if (!state.level.touches(movedY, this.size, ["wall", "lava"])) {\n            pos = movedY\n         }\n         //考虑要不要喷火,设定3秒冷却时间\n         let fire = this.fire;\n         if (Math.abs(xDistance) < 10 && Math.abs(yDistance) < 10 &&\n            Date.now() - fire.lastShot > 3000) {\n            fire.isFire = true;\n            fire.lastShot = Date.now()\n         } else {\n            this.fire.isFire = false;\n         }\n\n         return new Dragon(pos, new Vec(xSpeed, ySpeed), fire)\n      }\n   }\n\n   class Fire {\n      constructor(pos, speed, gone = false) {\n         this.pos = pos;\n         this.speed = speed;\n         this.size = new Vec(0.8, 1.4)\n         this.gravity = 10;\n         this.isGone = gone;\n      }\n      get type() {\n         return \'fire\'\n      }\n      static create(pos) {\n         return new Fire(pos, new Vec(0, 0))\n      }\n      collide(state) {\n         return new State(state.level, state.actors, \'lost\')\n      }\n      gone(state) {\n         let filtered = state.actors.filter(a => a != this);\n         return new State(state.level, filtered, state.status)\n      }\n      update(time, state) {\n         let pos = this.pos;\n         let xSpeed = this.speed.x\n         let gone = this.isGone;\n         let movedX = pos.plus(new Vec(xSpeed * time, 0))\n         if (!state.level.touches(movedX, this.size, ["wall", "lava"])) {\n            pos = movedX\n         } else {\n            gone = true;\n         }\n         let ySpeed = this.speed.y + this.gravity * time;\n         let movedY = pos.plus(new Vec(0, ySpeed * time));\n         if (!state.level.touches(movedY, this.size, ["wall", "lava"])) {\n            pos = movedY\n         } else {\n            gone = true;\n         }\n         return new Fire(pos, new Vec(xSpeed, ySpeed), gone)\n      }\n   }\n\n   var levelChars = {\n      ".": "empty", "#": "wall", "+": "lava",\n      "@": Player, "o": Coin,\n      "=": Lava, "|": Lava, "v": Lava, \'m\': Monster,\n      "d": Dragon, "f": Fire\n   };\n\n   //第二章：actors之间的碰撞与更新、state的更新\n\n   function overlap(moveActor, hitActor) {\n      //测试上下左右的碰撞位置\n      let actor1Left = moveActor.pos.x\n      let actor1Right = moveActor.size.x + moveActor.pos.x;\n      let actor1Top = moveActor.pos.y;\n      let actor1Bottom = moveActor.pos.y + moveActor.size.y;\n      let actor2Left = hitActor.pos.x\n      let actor2Right = hitActor.size.x + hitActor.pos.x;\n      let actor2Top = hitActor.pos.y;\n      let actor2Bottom = hitActor.pos.y + hitActor.size.y;\n      let hitPosition = {\n         top: false,\n         left: false,\n         right: false,\n         bottom: false\n      };\n      let hit = false;\n      if (actor1Right - actor2Left < hitActor.size.x &&\n         actor1Right - actor2Left > 0 &&\n         actor2Right - actor1Left > hitActor.size.x &&\n         actor1Top < actor2Bottom && actor1Bottom > actor2Top) {\n         hitPosition.left = true;\n         hit = true\n      }\n      if (actor2Right - actor1Left < hitActor.size.x &&\n         actor2Right - actor1Left > 0 &&\n         actor1Right - actor2Left > hitActor.size.x &&\n         actor1Top < actor2Bottom && actor1Bottom > actor2Top) {\n         hitPosition.right = true;\n         hit = true;\n      }\n      if (actor1Bottom - actor2Top < hitActor.size.y &&\n         actor1Bottom - actor2Top > 0 &&\n         actor2Bottom - actor1Top > hitActor.size.y &&\n         actor1Left < actor2Right && actor1Right > actor2Left) {\n         hitPosition.top = true;\n         hit = true;\n      }\n      if (actor2Bottom - actor1Top < hitActor.size.y &&\n         actor2Bottom - actor1Top > 0 &&\n         actor1Bottom - actor2Top > hitActor.size.y &&\n         actor1Left < actor2Right && actor1Right > actor2Left) {\n         hitPosition.bottom = true;\n         hit = true;\n      }\n      return hit ? hitPosition : hit\n\n   }\n   //第三章：canvas\n\n   function flipHorizontally(context, around) {\n      context.translate(around, 0);\n      context.scale(-1, 1);\n      context.translate(-around, 0);\n   }\n\n   ////渲染模式\n   class CanvasDisplay {\n      constructor(level, gameClass) {\n         this.canvas = document.createElement("canvas");\n         this.canvas.style.display = \'block\';\n         this.canvas.style.margin = \'auto\'\n         this.canvas.width = Math.min(gameWidth, level.width * scale);\n         this.canvas.height = Math.min(gameHeight, level.height * scale);\n         gameClass.dom.appendChild(this.canvas);\n         this.cx = this.canvas.getContext("2d");\n         this.flipPlayer = false;\n         this.flipDragon = false;\n         this.flipMonster = false;\n         this.flipFire = false;\n         this.viewport = {\n            left: 0,\n            top: 0,\n            //屏幕的3分之一\n            width: this.canvas.width / scale,\n            height: this.canvas.height / scale\n         };\n         this.gameClass = gameClass;\n      }\n      clear() {\n         this.canvas.remove();\n      }\n      updateViewport(state) {\n         let view = this.viewport, margin_width = view.width / 3, margin_height = view.height / 3;\n         let player = state.player;\n         let center = player.pos.plus(player.size.times(0.5));\n\n         if (center.x < view.left + margin_width) {\n            view.left = Math.max(center.x - margin_width, 0);\n         } else if (center.x > view.left + view.width - margin_width) {\n            view.left = Math.min(center.x + margin_width - view.width,\n               state.level.width - view.width);\n         }\n         if (center.y < view.top + margin_height) {\n            view.top = Math.max(center.y - margin_height, 0);\n         } else if (center.y > view.top + view.height - margin_height) {\n            view.top = Math.min(center.y + margin_height - view.height,\n               state.level.height - view.height);\n         }\n      }\n      clearDisplay(status) {\n         //通过game对应的level找到调出渲染的参数\n         let backgroundImage = this.gameClass.backgroundImage;\n         if (backgroundImage !== null) {\n            //处理游戏背景\n            this.cx.drawImage(backgroundImage, 0, 0, this.canvas.width, this.canvas.height)\n         } else {\n            //default background setting\n            if (status == "won") {\n               this.cx.fillStyle = "rgb(68, 191, 255)";\n            } else if (status == "lost") {\n               this.cx.fillStyle = "rgb(44, 136, 214)";\n            } else {\n               this.cx.fillStyle = this.gameClass.backgroundColor || "rgb(52, 166, 251)";\n            }\n            this.cx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n         }\n      }\n      drawBackground(level) {\n         let { left, top, width, height } = this.viewport;\n         let xStart = Math.floor(left);\n         let xEnd = Math.ceil(left + width);\n         let yStart = Math.floor(top);\n         let yEnd = Math.ceil(top + height);\n\n         for (let y = yStart; y < yEnd; y++) {\n            for (let x = xStart; x < xEnd; x++) {\n               let tile = level.rows[y][x];\n               if (tile == "empty") continue;\n               let screenX = (x - left) * scale;\n               let screenY = (y - top) * scale;\n               let tileX = tile == "lava" ? 2 * scale : 0;\n               this.cx.drawImage(otherSprites, tileX, 0, 2 * scale, 2 * scale,\n                  screenX, screenY, scale, scale);\n            }\n         }\n      }\n      drawPlayer(player, x, y, width, height) {\n         const playerXOverlap = 4;\n         width += playerXOverlap * 2;\n         x -= playerXOverlap;\n\n         if (player.speed.x != 0) {\n            this.flipPlayer = player.speed.x < 0;\n         }\n\n         let tile = 8;\n         if (player.speed.y != 0) {\n            tile = 9;\n         } else if (player.speed.x != 0) {\n            tile = Math.floor(Date.now() / 60) % 8;\n         }\n\n         this.cx.save();\n         if (this.flipPlayer) {\n            flipHorizontally(this.cx, x + width / 2);\n         }\n         let tileX = tile *  48;\n         this.cx.drawImage(this.gameClass.playerSprites, tileX, 0, 48, 60, x, y, width, height);\n         this.cx.restore();\n      }\n      drawMonster(monster, x, y, width, height) {\n         if (monster.speed.x != 0) {\n            this.flipMonster = monster.speed.x > 0;\n         }\n         this.cx.save();\n         if (this.flipMonster) {\n            flipHorizontally(this.cx, x + width / 2);\n         }\n         this.cx.drawImage(monsterSprites, x, y, width, height)\n         this.cx.restore()\n      }\n      drawDragon(dragon, x, y, width, height) {\n         if (dragon.speed.x != 0) {\n            this.flipDragon = dragon.speed.x > 0;\n         }\n         this.cx.save();\n         if (this.flipDragon) {\n            flipHorizontally(this.cx, x + width / 2);\n         }\n         let tile;\n         let afterFire = Date.now() - dragon.fire.lastShot;\n         if (afterFire < 240) {\n            //显示喷火图案\n            if (afterFire < 60) tile = 0;\n            else if (afterFire < 120) tile = 1;\n            else if (afterFire < 180) tile = 2;\n            else tile = 3\n            this.cx.drawImage(toFireSRC[tile], x, y, width, height)\n         } else {\n            //飞行图案\n            tile = Math.floor(Date.now() / 60) % 10;\n            this.cx.drawImage(dragonSpritesSRC[tile], x, y, width, height)\n         }\n         this.cx.restore()\n\n      }\n      drawFire(fire, x, y, width, height) {\n         if (fire.speed.x != 0) {\n            this.flipFire = fire.speed.x < 0;\n         }\n         let tile;\n         if (fire.speed.y < 2) {\n            tile = 0\n         } else if (fire.speed.y < 6) {\n            tile = 1\n         } else if (fire.speed.y < 10) {\n            tile = 2\n         } else {\n            tile = 3;\n         }\n         this.cx.save();\n         if (this.flipFire) {\n            flipHorizontally(this.cx, x + width / 2);\n         }\n         this.cx.drawImage(fireSpritesSRC[tile], x, y, width, height)\n         this.cx.restore()\n      }\n      drawActors(actors,status) {\n         for (let actor of actors) {\n            let width = actor.size.x * scale;\n            let height = actor.size.y * scale;\n            let x = (actor.pos.x - this.viewport.left) * scale;\n            let y = (actor.pos.y - this.viewport.top) * scale;\n            if (actor.type == "player") {\n               if (status !== \'lost\'){\n               this.drawPlayer(actor, x, y, width, height);\n            }else{\n               this.cx.font =`${actor.size.y * 30 }px Arial`\n               this.cx.fillText("💥",x,y+actor.size.y*20)\n               this.cx.restore()\n            }\n            } else if (actor.type == "monster") {\n               this.drawMonster(actor, x, y, width, height)\n            } else if (actor.type == "dragon") {\n               this.drawDragon(actor, x, y, width, height)\n            } else if (actor.type == "fire") {\n               this.drawFire(actor, x, y, width, height)\n            } else {\n               let tileX = (actor.type == "coin" ? 2 : 1) * 2 * scale;\n               this.cx.drawImage(otherSprites, tileX, 0, 2 * width, 2 * height, x, y, width, height);\n            }\n         }\n      }\n      drawProperty(actors) {\n         let numberOfCoin = actors.reduce((total, each) => {\n            each = each.type == \'coin\' ? 1 : 0;\n            return total + each\n         }, 0);\n         this.cx.font = \'15px Arial\';\n         this.cx.fillStyle = \'red\';\n         this.cx.fillText(`👦: ${ this.gameClass.lives } `, 10, 30);\n         this.cx.fillText(`💰: ${ numberOfCoin } `, 10, 55)\n         if (this.gameClass.totalLevel != 1) {\n            this.cx.fillText(`L: ${ this.gameClass.level + 1 } /${this.gameClass.totalLevel}`, 15, 80)\n         }\n      }\nsyncState(state) {\n  this.updateViewport(state);\n  this.clearDisplay(state.status);\n  this.drawBackground(state.level);\n  this.drawActors(state.actors,state.status);\n  this.drawProperty(state.actors)\n}\n   }\n\n//最后一章：游戏的运行\n\nfunction runAnimation(frameFunc) {\n  let lastTime = null;\n  function frame(time) {\n    if (lastTime != null) {\n      let timeStep = Math.min(time - lastTime, 100) / 1000;\n      if (frameFunc(timeStep) === false) return;\n    }\n    lastTime = time;\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n}\n\n\nfunction runLevel(level, gameClass) {\n  let display = new CanvasDisplay(level, gameClass);\n  let state = State.start(level);\n  let ending = 1;\n  let running = "yes";\n\n  return new Promise(resolve => {\n    function escHandler(event) {\n      if (event.key != "Escape") return;\n      event.preventDefault();\n      if (running == "no") {\n        running = "yes";\n        //true的时候，再call一次runAnimation\n        runAnimation(frame);\n      } else {\n        running = "no";\n      }\n    }\n    window.addEventListener("keydown", escHandler);\n    let arrowKeys = trackKeys(["ArrowLeft", "ArrowRight", "ArrowUp"]);\n    function frame(time) {\n      if (running == "no") {\n        return false;\n      }\n      state = state.update(time, arrowKeys, gameClass);\n      display.syncState(state);\n      if (state.status == "playing") {\n        return true;\n      } else if (ending > 0) {\n        ending -= time;\n        return true;\n      } else {\n        display.clear();\n        window.removeEventListener("keydown", escHandler);\n        arrowKeys.unregister();\n        resolve(state.status);\n        return false;\n      }\n    }\n    runAnimation(frame);\n  });\n}\n\nfunction trackKeys(keys) {\n  let down = Object.create(null);\n  function track(event) {\n    if (keys.includes(event.key)) {\n      down[event.key] = event.type == "keydown";\n      event.preventDefault();\n    }\n  }\n  window.addEventListener("keydown", track);\n  window.addEventListener("keyup", track);\n  down.unregister = () => {\n    window.removeEventListener("keydown", track);\n    window.removeEventListener("keyup", track);\n  };\n  return down;\n}\n\n\nclass Game {\n  constructor(dom) {\n    this.dom = dom;\n    this.playerSprites = srcToImage(playerSRC);\n    this.backgroundColor = "rgb(52, 166, 251)";\n    this.backgroundImage = null;\n    this.lives = 3;\n    this.speed = 7;\n    this.size = 1;\n    this.jumpSpeed = 17;\n  }\n   async runGame(plans, levelSettings = [], globalSettings) {\n      return new Promise(async (resolve) => {\n         //更改全球设置\n         if (globalSettings != undefined) {\n            this.mutate(globalSettings)\n         }\n         let startLives = this.lives\n         this.totalLevel = plans.length;\n         for (let level = 0; level < plans.length;) {\n            //重置属性\n            this.backgroundImage = null;\n            this.level = level;\n            //修改级别属性\n            if (levelSettings.length > 0) {\n               this.mutate(levelSettings[level])\n            }\n            let status = await runLevel(new Level(plans[level]), this);\n            if (status == \'won\') {\n               level++\n            } else {\n               this.lives--;\n            }\n            if (this.lives == 0) {\n               level = 0;\n               this.lives = startLives;\n            }\n         }\n         resolve(\'won\')\n      })\n      }\n      mutate(valueToBeMutated) {\n         let keys = Object.keys(valueToBeMutated);\n         keys.forEach(key => {\n            if (this[key] === undefined) throw new Error(\'no such property: \' + key)\n      \n            if (valueToBeMutated[key] != undefined) {\n               //这里要转化为image\n               if (key == \'backgroundImage\' || key ==\'playerSprites\'){\n                  let image = new Image();\n                  image.src = valueToBeMutated[key];\n                  this[key] = image;\n                  return;\n               }\n               this[key] = valueToBeMutated[key]\n            }\n         })\n      }\n\n\n}\n\n  function elt(type, props,style,...children) {\n    let dom = document.createElement(type);\n    if (props) Object.assign(dom, props);\n    if (style) {\n      for (let key in style){\n        dom.style[key] = style[key]\n      }\n    }\n    for (let child of children) {\n      if (typeof child != "string") dom.appendChild(child);\n      else dom.appendChild(document.createTextNode(child));\n    }\n    return dom;\n  }\n\n\n  let startUpFacebackgroundStyle = startUpFacebackgroundStyleToBeReplaced\n  let startBtnStyleFromVuex = startBtnStyleToBeReplace\n  let startUpBtnText = startUpBtnTextToBeReplace\n  let textComponents = textComponentsToBeReplace\n  let pictureComponents = pictureComponentsToBeReplace\n\n\n  let endFacebackgroundStyle = endFacebackgroundStyleToBeReplaced\n  let textFlowStyleFromVuex = textFlowStyleFromVuexToBeReplaced\n  let textFlowAnimationFromVuex = textFlowAnimationFromVuexToBeReplaced\n  let textFlowContent = textFlowContentToBeReplaced\n  let endTextComponents = endTextComponentsToBeReplace\n  let endPictureComponents = endPictureComponentsToBeReplace\n \n  //开头界面部分\n  let startUpFaceStyle = Object.assign({},startUpFacebackgroundStyle,{\n    margin: "auto",\n    position: "relative",\n    width: "700px",\n    height: "400px",\n    overflow: "hidden",\n    backgroundPosition: "center",\n  })\n\n  let startBtnStyle = Object.assign({},startBtnStyleFromVuex,{position: "absolute"})\n\n  let startBtnProps = {\n    type:\'button\',\n    onclick: async ()=>{\n      document.querySelector(\'.startUpFaceContainer\').remove()\n      await new Game(document.querySelector(\'#game\')).runGame(GAME_LEVELS,gameSettings,globalSettings);\n      document.body.appendChild(endFaceContainer)\n      return endFaceAnimation()\n    }\n  }\n\n  let pictureDom = pictureComponents.map(component=>{\n    return elt(\'div\',null,component.style,elt(\'img\',{src:component.url,width:component.width}))\n   })\n  let textDom = textComponents.map(component=>{\n    return elt(\'div\',null,component.style,component.textContent);\n  }) \n  let startBtn = elt(\'button\', startBtnProps,startBtnStyle,startUpBtnText)\n  let startUpFaceContainer = elt(\'div\', {className:\'startUpFaceContainer\'},startUpFaceStyle, startBtn,...textDom,...pictureDom)\n  document.body.appendChild(startUpFaceContainer)\n\n   //结尾界面部分\n  let endFaceStyle = Object.assign({},endFacebackgroundStyle,{\n    margin: "auto",\n    position: "relative",\n    width: "700px",\n    height: "400px",\n    overflow: "hidden",\n    backgroundPosition: "center",\n  })\n  let endPictureDom = endPictureComponents.map(component=>{\n    return elt(\'div\',null,component.style,elt(\'img\',{src:component.url,width:component.width}))\n   })\n  let endTextDom = endTextComponents.map(component=>{\n    return elt(\'div\',null,component.style,component.textContent);\n  }) \n\n  let textFlowDom = elt(\'pre\',null,textFlowStyleFromVuex,textFlowContent);\n  let endFaceContainer = elt(\'div\',{className:\'endFaceContainer\'},endFaceStyle,textFlowDom,...endTextDom,...endPictureDom)\n\n  function pixelTypeTransfer(value) {\n      if (typeof value == "string") {\n        return Number(value.match(/-?\\d+/)[0]);\n      } else {\n        return value + "px";\n      }\n   }\n\n  function endFaceAnimation(){\n     let {\n        animation,\n        animationTime,\n        animationDistance,\n        animationDir\n      } = textFlowAnimationFromVuex\n      if (animation == false || animationTime == 0 || animationDistance == 0)\n        return;\n      let time = animationTime * 1000;\n      let start = 0;\n      if (animationDir == "top" || animationDir == "bottom") {\n        let distance =\n          animationDir == "top" ? -1 * animationDistance : animationDistance;\n        let animate = setInterval(() => {\n          textFlowDom.style.top =\n            pixelTypeTransfer(textFlowDom.style.top) +\n            (distance / time) * 60 +\n            "px";\n          start += 60;\n          if (start > time) clearInterval(animate);\n        }, 60);\n      } else {\n        let distance =\n          animationDir == "left" ? -1 * animationDistance : animationDistance;\n        let animate = setInterval(() => {\n          textFlowDom.style.left =\n            pixelTypeTransfer(textFlowDom.style.left) +\n            (distance / time) * 60 +\n            "px";\n          start += 60;\n          if (start > time) clearInterval(animate);\n        }, 60);\n      }\n  }\n\n<\/script >\n\n\n</html >\n',y=n("ec45"),v={};function w(e){e.keys().forEach(function(t){return v[t]=e(t)})}w(n("3c10"));var x={name:"entrieGame",mixins:[y["a"]],beforeRouteLeave:function(e,t,n){null!=this.runningGame?(this.runningGame.stopGame(),n()):n()},beforeRouteEnter:function(e,t,n){function a(){var e=navigator.userAgent,t=e.indexOf("MSIE ")>-1||e.indexOf("Trident/")>-1;return t}a()?(alert("抱歉，目前不支持该浏览器，可以使用Chrome,Edge,Opera,Firefox,Safari等浏览器"),n(!1)):n()},mounted:function(){this.textFlowRealTimeStyle=JSON.parse(h()(this.endProcessTextFlow.style))},data:function(){return{runningGame:null,gameEnd:!1,textFlowRealTimeStyle:null}},watch:{gameEnd:function(){var e=this;if(0!=this.gameEnd){this.textFlowRealTimeStyle.top=this.endProcessTextFlow.style.top,this.textFlowRealTimeStyle.left=this.endProcessTextFlow.style.left;var t=this.endProcessTextFlow.animate,n=t.animation,a=t.animationTime,s=t.animationDistance,r=t.animationDir;if(0!=n&&0!=a&&0!=s){var i=1e3*a,o=0;if("top"==r||"bottom"==r)var l="top"==r?-1*s:s,c=setInterval(function(){e.textFlowRealTimeStyle.top=e.pixelTypeTransfer(e.textFlowRealTimeStyle.top)+l/i*60+"px",o+=60,o>i&&clearInterval(c)},60);else var p="left"==r?-1*s:s,u=setInterval(function(){e.textFlowRealTimeStyle.left=e.pixelTypeTransfer(e.textFlowRealTimeStyle.left)+p/i*60+"px",o+=60,o>i&&clearInterval(u)},60)}}}},computed:Object(p["a"])({},Object(f["d"])("playerFigure",{playerFigureImgData:"imgData",playerFigureWidth:null}),Object(f["d"])("gameLevel",["levelMap","levelSetting","currentLevel","structureDesign","globalPlayerSetting"]),Object(f["d"])("startUpFace",["startUpBtn","backgroundStyle","startUpBtnText"]),Object(f["b"])("startUpFace",["processTextComponent","processPictureComponent"]),Object(f["d"])("endFace",{endBackgroundStyle:"backgroundStyle"}),Object(f["b"])("endFace",{endProcessTextComponent:"processTextComponent",endProcessPictureComponent:"processPictureComponent",endProcessTextFlow:"processTextFlow"}),{gameContainer:function(){return document.querySelector(".gameContainer")},playerFigure:function(){var e=this.$store.state.playerFigure.result;if(null==e)return null;var t=new Image;return t.src=this.$store.state.playerFigure.result,t},lang:function(){return this.$store.state.lang}}),methods:{save:function(){function e(e,t){localStorage.setItem(e,h()(t))}e("gameLevel",this.$store.state.gameLevel),e("startUpFace",this.$store.state.startUpFace),e("endFace",this.$store.state.endFace),alert("".concat(1===this.lang?"已保存!":"Saved!"))},restore:function(){function e(e,t){var n=localStorage.getItem(e);null!=n&&t.$store.commit(e+"/restoreData",JSON.parse(n))}e("gameLevel",this),e("startUpFace",this),e("endFace",this),alert("".concat(1===this.lang?"已恢复, 请重新开始游戏!":"Done! Please restart the game!"))},reset:function(){if(1==this.gameEnd)return this.gameEnd=!1,void(this.runningGame=null);null!=this.runningGame&&this.runningGame.stopGame()},pixelTypeTransfer:function(e){return"string"==typeof e?Number(e.match(/-?\d+/)[0]):e+"px"},startGame:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return t=0==this.levelMap.length?m["a"]:this.levelMap,this.runningGame=new d["a"](this.gameContainer),e.next=4,this.runningGame.runGame(t,this.levelSetting,this.globalPlayerSetting);case 4:this.gameEnd=!0;case 5:case"end":return e.stop()}},e,this)}));function t(){return e.apply(this,arguments)}return t}(),goToPlayerFigureDesign:function(){this.$router.push("/playerFigure/combine")},goToGameDesign:function(){this.$router.push("/gameDesign")},goToStartUpAndEndDesign:function(){this.$router.push("/startUpAndEndDesign")},downloadTheGame:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(){var t,n,a,s,r;return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:if(r=function(e,t){return new l.a(function(){var n=Object(c["a"])(regeneratorRuntime.mark(function n(a){var s,r,o,c,p,u,d,f,g;return regeneratorRuntime.wrap(function(n){while(1)switch(n.prev=n.next){case 0:return g=function(e,t){var n=!0,a=!1,s=void 0;try{for(var r,o=i()(t);!(n=(r=o.next()).done);n=!0){var l=r.value;e=e.replace(new RegExp(l.spot),h()(l.value))}}catch(c){a=!0,s=c}finally{try{n||null==o.return||o.return()}finally{if(a)throw s}}return e},f=function(e,t,n){if(void 0==n){var a=t["./"+e];if(void 0==a)throw new Error("no such image");var s=new Image;return s.src=a,new l.a(function(e){s.onload=function(){var t=document.createElement("canvas");t.width=s.width,t.height=s.height;var n=t.getContext("2d");document.body.appendChild(t),n.drawImage(s,0,0);var a=t.toDataURL();t.remove(),s.remove(),e(a)}})}return new l.a(function(a){var s=Array.apply(null,{length:n}).map(function(n,a){var s=a+1,r=e.replace(/[.]/,s+".");return f(r,t)});l.a.all(s).then(function(e){return a(e)})})},n.next=4,f("sprites.png",v);case 4:return s=n.sent,n.next=7,f("player.png",v);case 7:return r=n.sent,n.next=10,f("Monster1.png",v);case 10:return o=n.sent,n.next=13,f("dragon.png",v,10);case 13:return c=n.sent,n.next=16,f("fire.png",v,4);case 16:return p=n.sent,n.next=19,f("tofire.png",v,8);case 19:u=n.sent,d=g(e,[{spot:"endFacebackgroundStyleToBeReplaced",value:t.endBackgroundStyle},{spot:"textFlowStyleFromVuexToBeReplaced",value:t.endProcessTextFlow.style},{spot:"textFlowAnimationFromVuexToBeReplaced",value:t.endProcessTextFlow.animate},{spot:"textFlowContentToBeReplaced",value:t.endProcessTextFlow.textContent},{spot:"endTextComponentsToBeReplace",value:t.endProcessTextComponent},{spot:"endPictureComponentsToBeReplace",value:t.endProcessPictureComponent},{spot:"pictureComponentsToBeReplace",value:t.processPictureComponent},{spot:"textComponentsToBeReplace",value:t.processTextComponent},{spot:"startUpFacebackgroundStyleToBeReplaced",value:t.backgroundStyle},{spot:"startBtnStyleToBeReplace",value:t.startUpBtn},{spot:"startUpBtnTextToBeReplace",value:t.startUpBtnText},{spot:"gameLevelToBeReplaced",value:0==t.levelMap.length?m["a"]:t.levelMap},{spot:"gameSettingsToBeReplaced",value:t.levelSetting},{spot:"globalSettingsToBeReplaced",value:t.globalPlayerSetting},{spot:"spritesToBeReplaced",value:s},{spot:"playerToBeReplaced",value:r},{spot:"monsterToBeReplaced",value:o},{spot:"drgonToBeReplaced",value:c},{spot:"fileToBeReplaced",value:p},{spot:"dragonToFireToBeReplaced",value:u}]),a([d]);case 22:case"end":return n.stop()}},n)}));return function(e){return n.apply(this,arguments)}}())},t=window.prompt("输入游戏名称","diyGame"),null!=t){e.next=4;break}return e.abrupt("return");case 4:return e.t0=Blob,e.next=7,r(g,this);case 7:e.t1=e.sent,e.t2={text:"text/plain"},n=new e.t0(e.t1,e.t2),a=window.URL.createObjectURL(n),s=document.createElement("a"),document.body.appendChild(s),s.setAttribute("href",a),s.setAttribute("download",t+".html"),s.click(),s.remove();case 17:case"end":return e.stop()}},e,this)}));function t(){return e.apply(this,arguments)}return t}()}},S=x,b=(n("9558"),n("2877")),T=Object(b["a"])(S,a,s,!1,null,"7c255a12",null);t["default"]=T.exports},"268f":function(e,t,n){e.exports=n("fde4")},"3b2b":function(e,t,n){var a=n("7726"),s=n("5dbc"),r=n("86cc").f,i=n("9093").f,o=n("aae3"),l=n("0bfb"),c=a.RegExp,p=c,u=c.prototype,h=/a/g,d=/a/g,m=new c(h)!==h;if(n("9e1e")&&(!m||n("79e5")(function(){return d[n("2b4c")("match")]=!1,c(h)!=h||c(d)==d||"/a/i"!=c(h,"i")}))){c=function(e,t){var n=this instanceof c,a=o(e),r=void 0===t;return!n&&a&&e.constructor===c&&r?e:s(m?new p(a&&!r?e.source:e,t):p((a=e instanceof c)?e.source:e,a&&r?l.call(e):t),n?this:u,c)};for(var f=function(e){e in c||r(c,e,{configurable:!0,get:function(){return p[e]},set:function(t){p[e]=t}})},g=i(p),y=0;g.length>y;)f(g[y++]);u.constructor=c,c.prototype=u,n("2aba")(a,"RegExp",c)}n("7a56")("RegExp")},"5df3":function(e,t,n){"use strict";var a=n("02f4")(!0);n("01f9")(String,"String",function(e){this._t=String(e),this._i=0},function(){var e,t=this._t,n=this._i;return n>=t.length?{value:void 0,done:!0}:(e=a(t,n),this._i+=e.length,{value:e,done:!1})})},9558:function(e,t,n){"use strict";var a=n("dab4"),s=n.n(a);s.a},a21f:function(e,t,n){var a=n("584a"),s=a.JSON||(a.JSON={stringify:JSON.stringify});e.exports=function(e){return s.stringify.apply(s,arguments)}},bf90:function(e,t,n){var a=n("36c3"),s=n("bf0b").f;n("ce7e")("getOwnPropertyDescriptor",function(){return function(e,t){return s(a(e),t)}})},cebc:function(e,t,n){"use strict";var a=n("268f"),s=n.n(a),r=n("e265"),i=n.n(r),o=n("a4bb"),l=n.n(o),c=n("85f2"),p=n.n(c);function u(e,t,n){return t in e?p()(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function h(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=l()(n);"function"===typeof i.a&&(a=a.concat(i()(n).filter(function(e){return s()(n,e).enumerable}))),a.forEach(function(t){u(e,t,n[t])})}return e}n.d(t,"a",function(){return h})},dab4:function(e,t,n){},e265:function(e,t,n){e.exports=n("ed33")},ec45:function(e,t,n){"use strict";t["a"]={created:function(){this.is_touch_device()&&(alert("".concat(1===this.lang?"游戏设计需在电脑端完成，以获得最佳体验":"To get the best experience, please start your design on computer.")),this.$router.push("/"))},methods:{is_touch_device:function(){return"ontouchstart"in window||navigator.MaxTouchPoints>0||navigator.msMaxTouchPoints>0}}}},ed33:function(e,t,n){n("014b"),e.exports=n("584a").Object.getOwnPropertySymbols},f499:function(e,t,n){e.exports=n("a21f")},fde4:function(e,t,n){n("bf90");var a=n("584a").Object;e.exports=function(e,t){return a.getOwnPropertyDescriptor(e,t)}}}]);
//# sourceMappingURL=entireGame.45073d0e.js.map